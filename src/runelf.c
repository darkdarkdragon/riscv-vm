// Most of this file generated by Claude

#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// #include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include "runelf-lib.h"
#include "riscv-vm-portable.h"

void print_section_flags(uint64_t flags) {
  printf("Flags: ");
  if (flags & SHF_WRITE)
    printf("WRITE ");
  if (flags & SHF_ALLOC)
    printf("ALLOC ");
  if (flags & SHF_EXECINSTR)
    printf("EXEC ");
  if (flags & SHF_MERGE)
    printf("MERGE ");
  if (flags & SHF_STRINGS)
    printf("STRINGS ");
  if (flags & SHF_INFO_LINK)
    printf("INFO_LINK ");
  printf("\n");
}

char *get_section_type(uint32_t sh_type) {
  switch (sh_type) {
  case SHT_NULL:
    return "NULL";
  case SHT_PROGBITS:
    return "PROGBITS";
  case SHT_SYMTAB:
    return "SYMTAB";
  case SHT_STRTAB:
    return "STRTAB";
  case SHT_RELA:
    return "RELA";
  case SHT_HASH:
    return "HASH";
  case SHT_DYNAMIC:
    return "DYNAMIC";
  case SHT_NOTE:
    return "NOTE";
  case SHT_NOBITS:
    return "NOBITS";
  case SHT_REL:
    return "REL";
  case SHT_SHLIB:
    return "SHLIB";
  case SHT_DYNSYM:
    return "DYNSYM";
  default:
    return "UNKNOWN";
  }
}

void print_elf_header_info(unsigned char *e_ident) {
  printf("ELF Header Information:\n");
  printf("Magic: %02x %02x %02x %02x\n", e_ident[0], e_ident[1], e_ident[2],
         e_ident[3]);
  printf("Class: %s\n", e_ident[EI_CLASS] == ELFCLASS32 ? "32-bit" : "64-bit");
  printf("Data: %s\n",
         e_ident[EI_DATA] == ELFDATA2LSB ? "Little-endian" : "Big-endian");
  printf("Version: %d\n", e_ident[EI_VERSION]);
  printf("\n");
}

char *get_segment_type(uint32_t p_type) {
  switch (p_type) {
  case PT_NULL:
    return "NULL";
  case PT_LOAD:
    return "LOAD";
  case PT_DYNAMIC:
    return "DYNAMIC";
  case PT_INTERP:
    return "INTERP";
  case PT_NOTE:
    return "NOTE";
  case PT_SHLIB:
    return "SHLIB";
  case PT_PHDR:
    return "PHDR";
  case PT_TLS:
    return "TLS";
  default:
    return "UNKNOWN";
  }
}

void print_segment_flags(uint32_t flags) {
  printf("Flags: ");
  if (flags & PF_R)
    printf("R");
  if (flags & PF_W)
    printf("W");
  if (flags & PF_X)
    printf("X");
  printf("\n");
}

/* Rest of the code remains the same as in previous version */
void process_elf32(void *file_data) {
  Elf32_Ehdr *ehdr = (Elf32_Ehdr *)file_data;
  Elf32_Phdr *phdr = (Elf32_Phdr *)((char *)file_data + ehdr->e_phoff);
  Elf32_Shdr *shdr = (Elf32_Shdr *)((char *)file_data + ehdr->e_shoff);
  char *strtab = (char *)file_data + shdr[ehdr->e_shstrndx].sh_offset;

  printf("Architecture: %s\n", get_machine_name(ehdr->e_machine));
  printf("Number of sections: %d\n", ehdr->e_shnum);
  printf("Entry: 0x%x\n\n", ehdr->e_entry);

  // Print Program Headers
  printf("\nProgram Headers (%d):\n", ehdr->e_phnum);
  for (int i = 0; i < ehdr->e_phnum; i++) {
    printf("\nProgram Header %d:\n", i);
    printf("Type: %s\n", get_segment_type(phdr[i].p_type));
    printf("Offset: 0x%x\n", phdr[i].p_offset);
    printf("VirtAddr: 0x%x\n", phdr[i].p_vaddr);
    printf("PhysAddr: 0x%x\n", phdr[i].p_paddr);
    printf("FileSize: 0x%x\n", phdr[i].p_filesz);
    printf("MemSize: 0x%x\n", phdr[i].p_memsz);
    print_segment_flags(phdr[i].p_flags);
    printf("Align: 0x%x\n", phdr[i].p_align);
  }

  // Print Section Headers
  printf("\nSection Headers (%d):\n", ehdr->e_shnum);

  for (int i = 0; i < ehdr->e_shnum; i++) {
    printf("Section %2d: %s\n", i, &strtab[shdr[i].sh_name]);
    printf("Type: %s\n", get_section_type(shdr[i].sh_type));
    printf("Address: 0x%x\n", shdr[i].sh_addr);
    printf("Offset: 0x%x\n", shdr[i].sh_offset);
    printf("Size: %u bytes\n", shdr[i].sh_size);
    print_section_flags(shdr[i].sh_flags);
    printf("\n");
  }
}

void run_elf32(void *file_data) {
  Elf32_Ehdr *ehdr = (Elf32_Ehdr *)file_data;
  Elf32_Shdr *shdr = (Elf32_Shdr *)((char *)file_data + ehdr->e_shoff);
  char *strtab = (char *)file_data + shdr[ehdr->e_shstrndx].sh_offset;

  // printf("Architecture: %s\n", get_machine_name(ehdr->e_machine));
  // printf("Number of sections: %d\n\n", ehdr->e_shnum);
  uint8_t *data = 0;
  uint32_t data_len = 0;
  uint32_t data_offset = 0;
  for (int i = 0; i < ehdr->e_shnum; i++) {
    if (strcmp(&strtab[shdr[i].sh_name], ".data") == 0) {
      data = (uint8_t *)((char *)file_data + shdr[i].sh_offset);
      data_len = shdr[i].sh_size;
      data_offset = shdr[i].sh_addr - ehdr->e_entry;
      printf(
          "Found .data section entry 0x%X data address 0x%X data_offset 0x%X\n",
          ehdr->e_entry, shdr[i].sh_addr, data_offset);
      break;
    }
  }

  for (int i = 0; i < ehdr->e_shnum; i++) {
    // printf("Section %2d: %s\n", i, &strtab[shdr[i].sh_name]);
    // printf("Type: %s\n", get_section_type(shdr[i].sh_type));
    // printf("Address: 0x%x\n", shdr[i].sh_addr);
    // printf("Offset: 0x%x\n", shdr[i].sh_offset);
    // printf("Size: %u bytes\n", shdr[i].sh_size);
    // print_section_flags(shdr[i].sh_flags);
    // printf("\n");
    if (strcmp(&strtab[shdr[i].sh_name], ".text.init") == 0) {
      printf("Found .text.init section\n");
      uint8_t *text = (uint8_t *)((char *)file_data + shdr[i].sh_offset);
      riscv_vm_run(NULL, text, shdr[i].sh_size, data, data_len, data_offset);
      break;
    }
  }
}


void process_elf64(void *file_data) {
  Elf64_Ehdr *ehdr = (Elf64_Ehdr *)file_data;
  Elf64_Shdr *shdr = (Elf64_Shdr *)((char *)file_data + ehdr->e_shoff);
  char *strtab = (char *)file_data + shdr[ehdr->e_shstrndx].sh_offset;

  printf("Architecture: %s\n", get_machine_name(ehdr->e_machine));
  printf("Number of sections: %d\n\n", ehdr->e_shnum);

  for (int i = 0; i < ehdr->e_shnum; i++) {
    printf("Section %2d: %s\n", i, &strtab[shdr[i].sh_name]);
    printf("Type: %s\n", get_section_type(shdr[i].sh_type));
    printf("Address: 0x%" PRIx64 "\n", shdr[i].sh_addr);
    printf("Offset: 0x%" PRIx64 "\n", shdr[i].sh_offset);
    printf("Size: %" PRIu64 " bytes\n", shdr[i].sh_size);
    print_section_flags(shdr[i].sh_flags);
    printf("\n");
  }
}

int main(int argc, char *argv[]) {
  int use_optimized = 0;
  int verbose = 0;
  int file_index = 1;
  if (argc < 2 || argc > 4) {
    fprintf(stderr, "Usage: [-opt] [-verbose] %s <elf-file>\n", argv[0]);
    return 1;
  }
  for (int i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-opt") == 0) {
      use_optimized = 1;
    } else if (strcmp(argv[i], "-opt2") == 0) {
      use_optimized = 2;
    } else if (strcmp(argv[i], "-opt3") == 0) {
      use_optimized = 3;
    } else if (strcmp(argv[i], "-opt4") == 0) {
      use_optimized = 4;
    } else if (strcmp(argv[i], "-verbose") == 0) {
      verbose = 1;
    } else {
      file_index = i;
    }
  }
  printf("Loading file %s\n", argv[file_index]);
  int fd = open(argv[file_index], O_RDONLY);
  if (fd < 0) {
    perror("Error opening file");
    return 1;
  }

  struct stat st;
  if (fstat(fd, &st) < 0) {
    perror("Error getting file size");
    close(fd);
    return 1;
  }

  void *file_data = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
  if (file_data == MAP_FAILED) {
    perror("Error mapping file");
    close(fd);
    return 1;
  }

  unsigned char *e_ident = (unsigned char *)file_data;
  if (memcmp(e_ident, ELFMAG, SELFMAG) != 0) {
    fprintf(stderr, "Not an ELF file\n");
    munmap(file_data, st.st_size);
    close(fd);
    return 1;
  }

  if (verbose) {
    print_elf_header_info(e_ident);
  }

  int exit_code = 0;
  if (e_ident[EI_CLASS] == ELFCLASS32) {
    // process_elf32(file_data);
    // run_elf32(file_data);
    exit_code = run_elf32v2(file_data, verbose, use_optimized);
  } else if (e_ident[EI_CLASS] == ELFCLASS64) {
    // process_elf64(file_data);
    fprintf(stderr, "Can't run 64 bit programs\n");
  } else {
    fprintf(stderr, "Unsupported ELF class\n");
  }

  munmap(file_data, st.st_size);
  close(fd);
  return exit_code;
}
